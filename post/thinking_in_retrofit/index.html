<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Retrofit的简单介绍 | Grinofith&#39;s Blog</title>
<link rel="shortcut icon" href="https://kanyewestforreal.github.io//favicon.ico?v=1741497022322">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://kanyewestforreal.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Retrofit的简单介绍 | Grinofith&#39;s Blog - Atom Feed" href="https://kanyewestforreal.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="Retrofit的简单介绍
Retrofit是一款注解型RESTful的网络框架，使用简单，扩展性强、耦合性低，安全性高。
Retrofit本质上是对OkHttp的封装。OkHttp已经是十分强大的武器，但是在具体使用上还是需要投入不少精力..." />
    <meta name="keywords" content="Android" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <!-- <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script> -->
    <script src="/media/js/highlight/highlight.min.js"></script>
    <script src="/media/js/sroll_markdown_titile_list.js"></script>
    <link rel="stylesheet" type="text/css" href="/media/js/highlight/styles/atom-one-dark.css">
    <script>hljs.highlightAll();</script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://kanyewestforreal.github.io/">
  <img class="avatar" src="https://kanyewestforreal.github.io//images/avatar.png?v=1741497022322" alt="">
  </a>
  <h1 class="site-title">
    Grinofith&#39;s Blog
  </h1>
  <p class="site-description">
    The key is seriously reflecting.
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Retrofit的简单介绍
            </h2>
            <div class="post-info">
              <span>
                2023-03-12
              </span>
              <span>
                43 min read
              </span>
              
                <a href="https://kanyewestforreal.github.io/tag/AndroidTAG/" class="post-tag">
                  # Android
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://cdnb.artstation.com/p/assets/images/images/045/245/713/large/col-price-out-from-the-shadows-medium.jpg?1642267723" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h2 id="retrofit的简单介绍"><strong>Retrofit的简单介绍</strong></h2>
<p><code>Retrofit</code>是一款注解型<code>RESTful</code>的网络框架，使用简单，扩展性强、耦合性低，安全性高。</p>
<p><code>Retrofit</code>本质上是对<code>OkHttp</code>的封装。<code>OkHttp</code>已经是十分强大的武器，但是在具体使用上还是需要投入不少精力，譬如：无法适配自动线程的切换、调用复杂、网络请求接口配置繁琐、缓存失效等问题。</p>
<p><code>Retrofit</code>由此孕育而生，为<code>OkHttp</code>如虎添翼。</p>
<h2 id="retrofit的简单使用"><strong>Retrofit的简单使用</strong></h2>
<p>由于<code>Retrofit</code>是对<code>OkHttp</code>的二次封装，所以<code>Retrofit</code>的使用与<code>OkHttp</code>大相径庭。</p>
<p>我们可以把对<code>Retrofit</code> 的实例理解为 <em>炮弹发射器</em>，我们对其一系列的初始的设置，可以理解为打造一款发射器，比如炮管长度，适合的弹药类型...</p>
<h3 id="tips"><strong>Tips：</strong></h3>
<p>使用跟网络相关的务必，务必，务必声明权限！否则容易花一堆时间浪费在debug上。</p>
<pre><code class="language-XML">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;
</code></pre>
<h3 id="初始化retrofit打造发射器"><strong>初始化Retrofit（打造发射器）</strong></h3>
<pre><code class="language-Java">Retrofit retrofit = new Retrofit.Builder()
          .baseUrl(&quot;https://netease.coderwdd.top/&quot;)//设置BaseURL以'/'结尾！
          .addConverterFactory(GsonConverterFactory.create())//数据解析器
          .build();//创建Retrofit对象
</code></pre>
<p>里面比较难理解的其实就是<em>数据转换器</em> <code>(Converter)</code>。</p>
<p>首先，我们要明白服务器一般返回的数据是<code>JSON（JavaScript Object Notation）</code>的字符串，可以理解为Python里的字典，即<code>K-V</code>的数据类型。不过还是有些服务器会返回<code>XML</code>类型的数据，在这里以普适性为主，选择介绍<code>JSON</code>。</p>
<p>不论返回的是<code>JSON</code>，还是<code>XML</code>，最原始的办法就是直接对其字符串操控，但这不够<em>优雅</em>！当你要读取里面大量的数据时，会略显狼狈和麻烦。而且这里还会遇到一个坑，就是只能调用一次<code>ResponseBody</code>(OkHttp的类)的<code>body().string()</code>方法，在第一次调用后，OkHttp会释放其缓存资源。</p>
<p>所以，想要方便地读取JSON里面的数据，可以把JSON转化为实体类。这时候就可以使用上一些开源库作为<code>Converter</code> (Java可以使用<code>Gson</code>，Kotlin可以使用<code>Moshi</code>)，或者是自定义自己的<code>Converter</code>。</p>
<h3 id="创建数据model"><strong>创建数据Model</strong></h3>
<p>由于我们需要优雅的读取JSON里面的数据，我们需要创建一个<em>实体类</em><code>(Bean)</code>，里面包含一些getter，setter方法，我们使用<code>Converter</code>把<code>JSON</code>等转化为<em>实体类</em>, 以此达到优雅读取其中数据的效果。</p>
<pre><code class="language-Java">public class AlbumBean {

   private long id;
   private String name;
   private String picUrl;

   public void setId(long id) {
       this.id = id;
  }
   public long getId() {
       return id;
  }

   public void setName(String name) {
       this.name = name;
  }
   public String getName() {
       return name;
  }

   public void setPicUrl(String picUrl) {
       this.picUrl = picUrl;
  }
   public String getPicUrl() {
       return picUrl;
  }

}
</code></pre>
<h3 id="定义接口对发射目标的确定"><strong>定义接口（对发射目标的确定）</strong></h3>
<pre><code class="language-Java">public interface NeteaseApiService {

   @GET(&quot;cloudsearch&quot;)
   Call&lt;AlbumBean&gt; getSongs(@Query(&quot;keywords&quot;) String name, @Query(&quot;keywords&quot;) intlimit);
}
</code></pre>
<p>由于上次<code>OkHttp</code>的铺垫，那么就默认大家都知道一些网络请求的常识，比如<code>GET</code>、<code>POST</code>请求，<code>URL</code>等。</p>
<p>上列代码实际上是<strong>将一个<strong><strong>API</strong></strong>转化为一个Java接口</strong>，传入的参数也将是构造URL的一部分。</p>
<p>在定义接口中，Retrofit的注释就闪亮登场了, 在后面解析源码过程中也会略微介绍Java的注解。</p>
<p><strong><code>@GET</code></strong> 表示我们的请求方式是GET请求，其后面接的表示接收一个字符串表示接口 <code>PATH</code> ，与 <code>BaseUrl</code> 组成完整的 <code>URL</code>。</p>
<p><strong><code>@Query</code></strong><code> </code>表示这是查询参数。</p>
<p>当然还有许多注释，可以去网上寻找更多相关资料。</p>
<p>我们可以看到<code>getSongs</code>方法返回的是<code>Call&lt;T&gt;</code></p>
<p>T就是<code>Converter</code>要把<code>JSON</code>转换成的类型，这里涉及到Java的一些特性，泛型擦除和反射等，在后面的<code>Retrofit</code>的源码解析中，将详细展开。</p>
<pre><code class="language-java">package retrofit2;

import java.io.IOException;
import okhttp3.Request;
import okio.Timeout;

public interface Call&lt;T&gt; extends Cloneable {
  
  Response&lt;T&gt; execute() throws IOException;

  void enqueue(Callback&lt;T&gt; callback);
  boolean isExecuted();
  void cancel();
  boolean isCanceled();
  Call&lt;T&gt; clone();
  Request request();
  Timeout timeout();
}
</code></pre>
<pre><code class="language-java">final class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; {
  private final RequestFactory requestFactory;
  private final Object[] args;
  private final okhttp3.Call.Factory callFactory;
  private final Converter&lt;ResponseBody, T&gt; responseConverter;

  OkHttpCall(
      RequestFactory requestFactory,
      Object[] args,
      okhttp3.Call.Factory callFactory,
      Converter&lt;ResponseBody, T&gt; responseConverter) {
    this.requestFactory = requestFactory;
    this.args = args;
    this.callFactory = callFactory;
    this.responseConverter = responseConverter;
  }
  ...
}
</code></pre>
<p><code>Call</code>由以上图片我们可以看到，它就是Retrofit执行网络请求的一个<strong>顶层接口</strong>, 它的具体实现类是 <strong><code>OkHttpCall</code></strong></p>
<h3 id="通过retrofit实例创建接口服务对象"><strong>通过Retrofit实例创建接口服务对象</strong></h3>
<pre><code class="language-Java">NeteaseApiService mApiService = retrofit.create(NeteaseApiService.class);
</code></pre>
<p>这里实际上涉及到了<code>Retrofit</code>比较核心的部分，我们需要知道<code>Retrofit</code>本质上是对<code>OkHttp</code>的二次封装，由Retrofit完成对请求的封装，再通过<code>OkHttp</code>完成后续的请求，等待服务器响应后，<code>Retrofit</code>再对响应根据需求进行解析。</p>
<p>只不过Retrofit使用了大量的<strong>设计模式</strong>，比如建造者模式、工厂模式、代理模式、策略模式等，实现了模块化解耦。</p>
<p>比如这里通过<strong>动态代理</strong>，使得我们只要在接口中定义方法，而不用实现该方法，以此达到高效、复用、简洁的效果。</p>
<h3 id="创建-执行网络请求">创建、执行网络请求</h3>
<p>以异步为例，使用<code>Call</code>执行网络请求</p>
<p>在这里，Retrofit实际上已经实现了<em>线程切换</em>，即将子线程切换到主线程，从而在主线程对返回的数据结果进行处理，在后面我们将详细解析。</p>
<pre><code class="language-Java">Call&lt;AlbumBean&gt; call = mApiService.getSongs(song.getName(), 1);

call.enqueue(new Callback&lt;AlbumBean&gt;() {
            @Override
            public void onResponse(Call&lt;AlbumBean&gt; call, Response&lt;AlbumBean&gt; response) {
                // 对返回的数据使用之前设置的数据转换器（Converter）解析返回的数据，
                // 最终得到一个Response&lt;T&gt;对象
                然后可以通过Response&lt;T&gt;对象判断状态，以此处理数据
            }
 
            @Override
            public void onFailure(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t) {
                出现错误，进行的操作
            }
        });
</code></pre>
<p>以上五步，基本上就是对Retrofit的简单使用。</p>
<p>接下来我们可以深入了解Retrofit，学会其中的设计模式，了解一个合格开源库是如何诞生的，了解鲁棒性高的代码编写风格。</p>
<h2 id="retrofit的结合使用"><strong>Retrofit的结合使用</strong></h2>
<p>关于Retrofit配合其他框架，这里推荐几篇文章，以免篇幅过长。</p>
<p>https://blog.csdn.net/carson_ho/article/details/79125101</p>
<p>https://blog.yujinyan.me/posts/kotlin-coroutine-retrofit/</p>
<h2 id="retrofit的源码解析"><strong>Retrofit的源码解析</strong></h2>
<p>接下来，接下来我们将开始解析Retrofit的源码。</p>
<h3 id="创建retrofit实例-解析"><strong>创建Retrofit实例</strong> 解析</h3>
<p>Retrofit实例是<strong>使用建造者模式通过Builder类</strong>进行创建的，</p>
<p>不过，我们先从Retrofit类看起，</p>
<h4 id="retrofit类">Retrofit类</h4>
<pre><code class="language-java">public final class Retrofit {
  private final Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;();

  final okhttp3.Call.Factory callFactory;
  final HttpUrl baseUrl;
  final List&lt;Converter.Factory&gt; converterFactories;
  final List&lt;CallAdapter.Factory&gt; callAdapterFactories;
  final @Nullable Executor callbackExecutor;
  final boolean validateEagerly;

  Retrofit(
      okhttp3.Call.Factory callFactory,
      HttpUrl baseUrl,
      List&lt;Converter.Factory&gt; converterFactories,
      List&lt;CallAdapter.Factory&gt; callAdapterFactories,
      @Nullable Executor callbackExecutor,
      boolean validateEagerly) {
    this.callFactory = callFactory;
    this.baseUrl = baseUrl;
    this.converterFactories = converterFactories; // Copy+unmodifiable at call site.
    this.callAdapterFactories = callAdapterFactories; // Copy+unmodifiable at call site.
    this.callbackExecutor = callbackExecutor;
    this.validateEagerly = validateEagerly;
  }
  ...
}
</code></pre>
<p>我们可以看到下面的<em>Retrofit的构造函数</em>，有一长串参数，所以实际应用中如果我们通过构造函数创建一个Retroift的实例，会显得有些复杂冗长。这时<strong>建造者模式</strong>就出场了。我们只需要不断调用方法，一个复杂对象就被创建了。</p>
<p><strong>由以上Builder类和Retrofit类的构造函数，我们可以的得知，创建成功一个Retrofit对象的标准：需要配置好以下变量</strong></p>
<ul>
<li><code>callFactory</code>：网络请求工厂</li>
<li><code>baseUrl</code>：网络请求的URL地址</li>
<li><code>converterFactories</code>：数据转换器工厂的集合，负责存储数据转换器工厂</li>
<li><code>adapterFactories</code>：网络请求适配器工厂的集合，负责存储网络请求适配器工厂</li>
<li><code>callbackExecutor</code>：回调方法执行器</li>
<li><code>validateEagerly</code>: 标志位, 是否要急切的验证请求方法，开启则会马上加载Api接口所有方法。一般不用</li>
</ul>
<p>简单讲述一下，以上变量的作用。</p>
<pre><code class="language-Java">private final HttpUrl baseUrl; // 网络请求的url地址 
private final okhttp3.Call.Factory callFactory; 
// 网络请求器的工厂
// 作用：生产网络请求器（Call） 
// Retrofit是默认使用okhttp 
private final List&lt;CallAdapter.Factory&gt; adapterFactories; 
// 网络请求适配器工厂的集合 
// 作用：放置网络请求适配器工厂 
// 网络请求适配器工厂作用：生产网络请求适配器（CallAdapter） 
// 下面会详细说明 
private final List&lt;Converter.Factory&gt; converterFactories; 
// 数据转换器工厂的集合 
// 作用：放置数据转换器工厂 
// 数据转换器工厂作用：生产数据转换器（converter）
private final Executor callbackExecutor; // 回调方法执行器 
private final boolean validateEagerly; 
// 标志位 
// 作用：是否提前对业务接口中的注解进行验证转换的标志位
</code></pre>
<p>在观察变量中，我们可以看到所谓<code>xxxFactory</code>这类命名的变量，比如<code>callFactory</code>，“xxx工厂”其实是设计模式中<strong>工厂模式</strong>的体现：将“类实例化的操作”与“使用对象的操作”分开，使得使用者不用知道具体参数就可以实例化出所需要的“产品”类。</p>
<p>通过<code>xxxFactory</code>的命名我们可以知道，最终生产出的就是<code>xxx</code>，例如<code>CallFactory</code>生产出<code>Call</code>，<code>CallAdapterFactory</code>生产的是<code>CallAdapter</code>。</p>
<p>在之前的定义接口中，我们已经大概知道<code>Call</code>的作用，作为一个顶层接口，其实现类是<code>OkHttpCall</code>，负责实现真正的网络请求。</p>
<p>那现在我们来解析一下<code>CallAdapter</code>的作用。</p>
<p><em>Adapter</em>即适配器的意思，我们就可以明白<code>CallAdapter</code>是网络请求执行器（Call）的适配器</p>
<blockquote>
<p>在Retrofit中提供了四种<em>CallAdapterFactory</em>：<code> ExecutorCallAdapterFactory</code>（默认）、<code>GuavaCallAdapterFactory</code>、<code>Java8CallAdapterFactory</code>、<code>RxJavaCallAdapterFactory</code></p>
<p>提供了这几类Adapter，实际上实现了<strong>策略模式</strong>，让Retrofit能够被多个平台/其他框架调用，实现了一定的拓展性。由以上命名我们也可以得知，Retrofit还支持Java8、Guava平台。</p>
</blockquote>
<p><strong>作用</strong>：将默认的网络请求执行器（OkHttpCall）转换成适合被不同平台来调用的网络请求执行器形式。比如，对原始Call进行再次封装，如Call到Observable。</p>
<blockquote>
<p>如：<code>Retrofit</code>可以利用<code>ExecutorCallbackCall</code>使<code>OkHttpCall</code>在请求中切换线程；</p>
<p>想要使用<code>Rxjava</code>不切换线程，那就得使用<code>RxJavaCallAdapterFactoryCallAdapter</code>将<code>OkHttpCall</code>转换成<code>Rxjava(Scheduler)</code>。</p>
</blockquote>
<p>例如</p>
<pre><code class="language-Java">// 把response封装成rxjava的Observeble，然后进行流式操作
Retrofit.Builder.addCallAdapterFactory(new RxJavaCallAdapterFactory().create()); 
</code></pre>
<p>其实我们再仔细观察<code>Retrofit</code>类的源码，我们可以看到一个至关重要的变量。</p>
<pre><code class="language-Java">private final Map&lt;Method, ServiceMethod&gt; serviceMethodCache = new LinkedHashMap&lt;&gt;(); 
// 网络请求配置对象（对网络请求接口中方法注解进行解析后得到的对象） 
// 作用：存储网络请求相关的配置，如网络请求的方法、数据转换器、网络请求适配器、网络请求工厂、基地址等
</code></pre>
<p>它负责<em>存储</em>解析Api接口后产生的方法，我们可以看到，如果有二次调用，将会直接从该集合中调取，而不是再次解析，实现了复用和节约内存、时间，后面我们还会提到**<code>loadServiceMethod</code>**这一方法。</p>
<pre><code class="language-java">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) {
  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);
  if (result != null) return result;

  synchronized (serviceMethodCache) {
    result = serviceMethodCache.get(method);
    if (result == null) {
      result = ServiceMethod.parseAnnotations(this, method);
      serviceMethodCache.put(method, result);
    }
  }
  return result;
}
</code></pre>
<h4 id="retrofitbuilder类">Retrofit.Builder类</h4>
<p>现在我们再来认真看看Retrofit.Builder类</p>
<pre><code class="language-Java">&lt;-- Builder类--&gt; 
public static final class Builder {
    public Builder() {
      this(Platform.get());
    }
    // Builder的构造方法（无参） 
    // 用this调用自己的有参构造方法p
    ublic Builder(Platform platform)
    // 并通过调用Platform.get（）传入了Platform对象 
    // 那么接下来继续看Platform.get()方法
    
    //解析完Platform.get()方法后，我们再看Builder的有参构造函数
    } 
... 
}
class Platform {
  private static final Platform PLATFORM = findPlatform();

  static Platform get() {
    return PLATFORM;
    // 返回静态变量PLATFORM，即findPlatform(),以下方法
  }

  private static Platform findPlatform() {
    return &quot;Dalvik&quot;.equals(System.getProperty(&quot;java.vm.name&quot;))
    ? new Android() 
    //最后返回一个Platform对象（指定了Android平台）
    //给Builder的有参构造方法public Builder(Platform platform)
    : new Platform(true);
  }


  static final class Android extends Platform {
    Android() {
      super(Build.VERSION.SDK_INT &gt;= 24);
    }

    @Override
    public Executor defaultCallbackExecutor() {
      // 返回一个默认的回调方法执行器，
      //在Retrofit实例创建时被调用（Retrofit.Builder()...build()中被调用)
      //作为默认的回调执行器，完成自动切换线程
      // 该执行器作用：切换线程（子-&gt;&gt;主线程），并在主线程（UI线程）中执行回调方法
      return new MainThreadExecutor();
    }

    static final class MainThreadExecutor implements Executor {
      private final Handler handler = new Handler(Looper.getMainLooper());
      // 获取与Android 主线程绑定的Handler 
        
        
      @Override
      public void execute(Runnable r) {
        handler.post(r);
         // 该Handler是上面获取的与Android 主线程绑定的Handler 
        // 在UI线程进行对网络请求返回数据处理等操作。
      }
    }
  }
}
// Builder类的构造函数（有参） 
public  Builder(Platform platform) { 
    // 接收Platform对象（Android平台）
    this.platform = platform; 
    
    // 通过传入BuiltInConverters()对象，配置数据转换器工厂（converterFactories） 
    
    // converterFactories负责存放数据转换器工厂（Converter.Factory）

    converterFactories.add(new BuiltInConverters()); 
    // BuiltInConverters是一个内置的数据转换器工厂（继承Converter.Factory类） 
    
    // new BuiltInConverters()是作为默认的数据转换器工厂
}
</code></pre>
<p>对Builder类分析完毕，总结：Builder<strong>设置了默认的</strong></p>
<ul>
<li>平台类型对象：<code>Android</code></li>
<li>网络请求适配器工厂：<code>CallAdapterFactory</code></li>
<li>数据转换器工厂： <code>converterFactory</code></li>
<li>回调执行器：<code>callbackExecutor</code></li>
</ul>
<p>这意味着，如果我们在初始化<code>Retrofit</code>时对一些变量没有设置，那么<code>Builder</code>设置的默认变量就会生效。这一点，我们可以由<code>Builder.build()</code>方法明白。</p>
<pre><code class="language-Java">public Retrofit build() {
    
  &lt;--  配置网络请求执行器（callFactory）--&gt;
  //这就是为什么说实际上Retrofit是对OkHttp的封装，实际上是通过OkHttp进行请求
  okhttp3.Call.Factory callFactory = this.callFactory;
  if (callFactory == null) {
    callFactory = new OkHttpClient();
  }
  
  
  &lt;--  配置回调方法执行器（callbackExecutor）--&gt;
  Executor callbackExecutor = this.callbackExecutor;
  // 如果没指定，则默认使用Platform检测环境时的默认callbackExecutor
  // 即Android默认的callbackExecutor
  if (callbackExecutor == null) {
    callbackExecutor = platform.defaultCallbackExecutor();
    //我们可以看到这行代码很眼熟，这里就是返回一个自动切换线程的回调器
  }
  
  //保护性Copy集合
  &lt;--  配置网络请求适配器工厂（CallAdapterFactory）--&gt;
  List&lt;CallAdapter.Factory&gt; callAdapterFactories 
      = new ArrayList&lt;&gt;(this.callAdapterFactories);
  // 向Retrofit类的该集合中添加了，Builder中创建的CallAdapter.Factory请求适配器工厂（添加在集合器末尾）   
  
  callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));
  //这时再添加默认适配器工厂（ExecutorCallAdapterFactory）
  
  //所以我们说在初始化Retrofit时对一些变量没有设置，那么Builder设置的默认变量就会生效
    

  List&lt;Converter.Factory&gt; converterFactories =
      new ArrayList&lt;&gt;(
          1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());

  converterFactories.add(new BuiltInConverters());
  //内置的数据转换器工厂BuiltInConverters(）放在首位
  
  converterFactories.addAll(this.converterFactories);
  //通过addConverterFactory（）添加的数据转换器工厂，放在其次位
  
  converterFactories.addAll(platform.defaultConverterFactories());
  //

  // 最终返回一个Retrofit的对象，并传入上述已经配置好的成员变量，这就是建造者模式
  return new Retrofit(
      callFactory,
      baseUrl,
      //unmodifiableList（）方法的效果是返回一个不可被修改的集合，这样就增强了程序的鲁棒性
      unmodifiableList(converterFactories),
      unmodifiableList(callAdapterFactories),
      callbackExecutor,
      validateEagerly);
}
</code></pre>
<p>总结：在最后一步中，通过前面步骤设置的变量，将Retrofit类的所有成员变量都配置完毕，成功创建了Retrofit的实例。</p>
<h3 id="定义接口-解析"><strong>定义接口</strong> 解析</h3>
<pre><code class="language-Java">public interface NeteaseApiService {

   @GET(&quot;cloudsearch&quot;)
   Call&lt;AlbumBean&gt; getSongs(@Query(&quot;keywords&quot;) String name, @Query(&quot;keywords&quot;) intlimit);
}
</code></pre>
<p>这里我们主要解析的是<em><strong>注解</strong></em>，<em><strong>注解</strong></em>是一种可以达到简洁明了的编程方法。通过注解我们可以简化逻辑，更加简单完成封装。</p>
<p>在Android常用开源库中，我们可以经常看见注解的出现，比如说现在流行的<code>Retrofit</code>，<code>DataBinding</code>等。或者说，曾经大火的<code>ButterKnife</code>和<code>Dagger</code>等中，都能看见它们的身影，不过在Google主打<code>MVVM</code>，推出一系列开源库为<code>MVVM</code>提供标准后，这些大火的开源库已经很少见到使用了。</p>
<p>话不多说，现在开始进入注解的世界。</p>
<h4 id="注解">注解</h4>
<h5 id="元注解">元注解</h5>
<p><em>元注解</em>，我们可以理解为这是<em>注解的</em><em><em>注解。**用来定义</em>注解的</em><strong>作用目标</strong>，<strong>保留策略</strong>等；</p>
<pre><code class="language-Java">@Documented //是否被javadoc或类似工具记录在文档中

@Inherited //标识注解是否可以被子类继承，A类标记注解，B类继承A类，那么B类也将继承注解

@Retention(RetentionPolicy.XXX) //表明这个注解是应用什么策略，其可以传入枚举值，只能生效一个保留策略

@Target(ElementType.XXX) //表明这个注解是使用在什么上，其可以传入枚举值，可以生效多个作用目标。
</code></pre>
<p>通过源码，我们可以得知Retention和Target能够应用的枚举值</p>
<pre><code class="language-Java">package java.lang.annotation;

public enum ElementType {
    TYPE,               // 类、接口（包括注释类型）或枚举声明  

    FIELD,              // 字段声明（包括枚举常量）  

    METHOD,             // 方法声明

    PARAMETER,          // 参数声明

    CONSTRUCTOR,        // 构造方法声明

    LOCAL_VARIABLE,     // 局部变量声明 

    ANNOTATION_TYPE,    // 注释类型声明 

    PACKAGE             // 包声明  
}
package java.lang.annotation;
public enum RetentionPolicy {
    SOURCE,            //Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了
                       //比如说@OVERRIDE就是使用该保留策略，在编译期间会进行语法检查，编译器处理完后就会消失
                       //应对着 Java源文件(.java文件)
                       
    CLASS,             // 编译器将Annotation存储于类对应的.class文件中。默认行为
                       // 应对着 .class文件

    RUNTIME            // 编译器将Annotation存储于class文件中，并且可由JVM读入
                       // 应对着 内存中的字节码
}

总结一下：
一般如果需要在运行时去动态获取注解信息，那只能用 RUNTIME 注解；
如果要在编译时进行一些预处理操作，比如生成一些辅助代码（如 ButterKnife），就用 CLASS注解；
如果只是做一些检查性的操作，比如 @Override 和 @SuppressWarnings，则可选用 SOURCE 注解。
</code></pre>
<ul>
<li><code>Documented</code>：是否被javadoc或类似工具记录在文档中；</li>
<li><code>Inherited</code>：标识注解是否可以被子类继承；</li>
<li><code>Target</code>：作用目标，在<code>ElementType</code>枚举中可以看到取值包括类、方法、属性等；</li>
<li><code>Retention</code>：保留策略，比如编译阶段是否丢弃，运行时保留；</li>
</ul>
<h5 id="定义注解">定义注解</h5>
<p>我们直接看看<code>@GET</code>注解，</p>
<pre><code class="language-Java">@Documented 
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface GET {
  //以下是注解参数的定义
  String value() default &quot;&quot;;
  //int type() default 0;
  //String level() default &quot;info&quot;;
}
</code></pre>
<p>出现了<code>@interface</code>，这是<strong>定义一个注释类型必须出现的关键词</strong>。</p>
<p>本质上看注解是接口，但是代码并没有显式声明继承关系，可以直接查看字节码文件：</p>
<pre><code>@interface`被替换成了`extends java.lang.annotation.Annotation
</code></pre>
<p>我们在观察主体代码，我添加一些定义参数的例子，我们可以发现定义参数跟定义无参数方法差不多。</p>
<p>首先明确参数类型</p>
<p>再明确参数名，加上括号</p>
<p>我们再可以使用<code>default</code>关键词设定一个默认值，当然也可以省略。</p>
<h5 id="处理注解">处理注解</h5>
<p>在之前我们观察了<code>Retrofit</code>的<code>@GET</code>注解，实际上如果注解只是这样，就只是一个花架子。注解一般对代码逻辑不会有任何影响。</p>
<p>但是，因为注解定义后也是一种<code>class</code>，所有的注解都继承自<code>java.lang.annotation.Annotation</code>，因此，我们可以读取注解，通过使用<strong>反射****API</strong>。</p>
<p>Java提供的使用反射API读取<code>Annotation</code>的方法：</p>
<p><code>Class</code>、<code>Field</code>、<code>Method</code>、<code>Constructor</code>可以调用</p>
<ul>
<li>***判断某个注解是否存在，***用<code>isAnnotationPresent(AnnotationName.class)</code>下方法，将返回boolean值。</li>
<li><em><strong>读取所有注解</strong></em>*，*可以使用<code>getAnnotations(AnnotationName.class)</code>方法，将返回一个Annotation[]数组, 如果<code>Annotation</code>不存在，将返回<code>null</code>。</li>
</ul>
<p><em><strong>如果想要获得有参的注解的值，可以直接调用获得。</strong></em></p>
<p>比如说：</p>
<pre><code class="language-Java">(（GET) annotation).value
</code></pre>
<p>对于读取 <em><strong>方法的参数</strong></em> <strong>的注解</strong> 应该使用<code>Method.getParameterAnnotations()</code>，因为 <em><strong>方法的参数</strong></em>  不止一个，将返回一个二维数组<code>Annotation[][]</code>，比如说：</p>
<pre><code class="language-Java">// 第一个参数（索引为0）的所有Annotation:
Annotation[] firstArg = annos[0];
// 第二个参数（索引为1）的所有Annotation:
Annotation[] secondArg = annos[1];
</code></pre>
<p>还有一些没有详细介绍的，我也列举出来：</p>
<pre><code class="language-Java">/**
 * 获取指定类型的注解
 */
public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationType);
 
/**
 * 获取所有注解，如果有的话
 */
public Annotation[] getAnnotations();
 
/**
 * 获取所有注解，忽略继承的注解
 */
public Annotation[] getDeclaredAnnotations();
 
/**
 * 指定注解是否存在该元素上，如果有则返回true，否则false
 */
public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationType);
 
/**
 * 获取Method中参数的所有注解
 */
public Annotation[][] getParameterAnnotations();
</code></pre>
<p>在下一步中我们将再次运用到注释的知识。</p>
<h3 id="小总结">小总结</h3>
<p>解析了Retrfit类是如何创建的——通过Builder内部类。</p>
<p>再进入Builder类内观察，发现配置了大量成员变量——有重要的：</p>
<ul>
<li><code>callFactory</code>：网络请求工厂</li>
<li><code>baseUrl</code>：网络请求的URL地址</li>
<li><code>converterFactories</code>：数据转换器工厂的集合，负责存储数据转换器工厂</li>
<li><code>adapterFactories</code>：网络请求适配器工厂的集合，负责存储网络请求适配器工厂</li>
<li><code>callbackExecutor</code>：回调方法执行器</li>
<li><code>validateEagerly</code>: 标志位, 是否要急切的验证请求方法，开启则会马上加载Api接口所有方法。</li>
</ul>
<p>然后再对定义接口解析，里面使用了注解，同时简略地讲了注解的定义使用，明白了注释是如何一步步被解析为请求的。</p>
<h3 id="创建接口服务对象-解析"><strong>创建接口服务对象 解析</strong></h3>
<pre><code class="language-Java">NeteaseApiService mApiService = retrofit.create(NeteaseApiService.class);
</code></pre>
<p>到这里，已经涉及到<code>Retrofit</code>的核心设计之一——动态代理。</p>
<p>我们先解释代理模式，在进行源码解析。</p>
<p><strong>代理模式</strong>分为<em>动态代理</em>，<em>静态代理</em>，<em>cglib代理</em>。代理模式提供了对<em>目标对象</em>额外的访问方式，即通过代理对象访问目标对象，这样可以在<strong>不修改原目标对象的前提下</strong>，提供<strong>额外的功能操作</strong>，<strong>扩展</strong>目标对象的功能。</p>
<p>简言之，代理模式就是<strong>设置一个中间代理</strong>来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。</p>
<h5 id="静态代理">静态代理</h5>
<p>先介绍<strong>静态代理</strong>，这种代理方式<strong>需要代理对象和目标对象实现一样的接口</strong>。</p>
<p>优点：可以在不修改目标对象的前提下扩展目标对象的功能。</p>
<p>缺点：</p>
<ol>
<li>冗余。由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。</li>
<li>不易维护。一旦接口增加方法，目标对象与代理对象都要进行修改。</li>
</ol>
<p>举一个栗子，某老师的作用是检查作业。那么某老师的中间代理人是学习委员，学委代收作业给老师检查，然后记下没有完成作业的人。</p>
<p>我们知道老师都会检查作业，所以新建一个接口抽象。</p>
<pre><code class="language-Java">public interface ITeacherDao {
   public void check(作业 book);
}
</code></pre>
<p>目标对象:某老师</p>
<pre><code class="language-Java">public class TeacherDao implements ITeacherDao{

   @Override
   public void check(作业 book) {
        检查作业 
  }
}    
</code></pre>
<p>中间代理:学委</p>
<pre><code class="language-Java">public class TeacherDaoProxy implements ITeacherDao{

   private ITeacherDao target;
   public TeacherDaoProxy(ITeacherDao target) {
       this.target = target;
  }
   
   @Override
   public void check(作业 book) {;
       target.check(作业 book);
       //扩展了额外功能
       if 作业完成：
         不记名
       else
         记名
  }
}
</code></pre>
<p>测试类</p>
<pre><code class="language-Java">public class StaticTeacherProxy {
   public void testStaticProxy(){
       //目标对象
       ITeacherDao target = new TeacherDao();
       //代理对象
       TeacherDaoProxy proxy = new TeacherDaoProxy(target);
       proxy.check();//调用了学委的check
  }
}
</code></pre>
<p>首先解释一下，为什么<code>代理类</code>和<code>委托类</code>要实现相同接口？是为了尽可能保证<code>代理类</code>的内部结构和<code>委托类</code>一致，这样对<code>委托类</code>的操作都可以转移到<code>代理类</code>上，<code>代理类</code>可以实现<strong>增强和控制</strong>。比如，我让学委拓展了记名、不记名的功能。</p>
<h5 id="动态代理">动态代理</h5>
<p>动态代理利用了<code>JDK API</code>，<em><strong>动态地</strong></em>在内存中构建代理对象，从而实现对目标对象的代理功能。动态代理又被称为<em>JDK代理或接口代理。</em></p>
<p>静态代理与动态代理的区别主要在：</p>
<ul>
<li>静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件</li>
<li>动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，<em><strong>而是在运行时动态生成类字节码由</strong></em><em><strong>JVM</strong></em><em><strong>帮助我们生成</strong></em> <em><strong>代理对象的类，同时实现接口</strong></em>***，并加载到JVM中***。由此动态代理也更加<em><strong>灵活</strong></em>、一定程度上<em><strong>减少了重复代码</strong></em>，比如像使用静态代理，我们需要手动完成<code>代理类</code>实现接口，才能调用<code>委托类</code>的方法实现增强控制，当委托类多起来时，<code>代理类</code>就会无限膨胀，维护困难。</li>
</ul>
<p><strong>特点：</strong> 动态代理对象不需要实现接口，但是要求目标对象必须实现接口，否则不能使用动态代理。</p>
<p>首先我们看看JDK API关于动态代理的源码，主要有两个</p>
<p>在<code>Proxy类</code>下</p>
<pre><code class="language-Java">//有三个参数
//为目标对象生成一个代理实例
public static Object newProxyInstance
(
    ClassLoader loader,      //产生代理对象的类加载器，需要将其指定为和目标对象同一个类加载器
    Class&lt;?&gt;[] interfaces,    //代理对象需要实现的接口，一般与目标对象实现接口相同，这样就能调用这组接口中的方法
    InvocationHandler h      //事件处理器
) 
//返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序。
</code></pre>
<p>这里简单介绍下<em><strong>类加载器</strong></em>，一般来说，Java 类的虚拟机使用 Java 方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 <code>java.lang.Class</code>类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 <code>newInstance()</code>方法就可以创建出该类的一个对象。</p>
<ul>
<li><code>InvocationHandler</code>是一个接口，一般<em><strong>使用匿名对象</strong></em>实现<code>invoke()</code>并传入<code>newProxyInstance（）</code>方法</li>
</ul>
<pre><code class="language-Java"> //这里的返回的Object，是执行method方法后返回的值
 public Object invoke(Object proxy, Method method, Object[] args) 
 // 在代理实例上处理方法调用并返回结果。
 // 参数说明：
 // 参数1：代表动态代理对象
 // 参数2：代表需要执行的方法
 // 参数3：传递给方法的一系列参数，可以为空
</code></pre>
<p>举个栗子，还是老师、学委：</p>
<pre><code class="language-Java">public interface ITeacherDao {
   public void check(作业 book);
}
</code></pre>
<p>目标对象:某老师</p>
<pre><code class="language-Java">public class TeacherDao implements ITeacherDao{

   @Override
   public void check(作业 book) {
        检查作业 
  }
}  
</code></pre>
<p>这时候我们可以不用编写<code>中间代理类</code>，而是编写调用<code>JDK API</code>帮我们动态生成<code>代理类</code>的代码，可以选择使用匿名类，也可以单独写一个<code>ProxyFactory类</code>。</p>
<p>这里我们选择单独写一个<code>ProxyFactory类</code>，后面再看<code>Retrofit</code>是如何运用动态代理的：</p>
<pre><code class="language-Java">public class ProxyFactory {
    //target是需要传入的目标对象
    public static Object newInstance(Object target){
        // 为目标对象生成代理对象
        return 
            Proxy.newProxyInstance(
                target.getClass().getClassLoader(), 
                target.getClass().getInterfaces(),
                new InvocationHandler() {
                
                     //通过 代理对象 调用 目标对象 的方法
                     //而这个方法又被分发给 InvocationHandler接口 的 invoke来执行
                     //invoke 方法返回的就是 调用方法返回的
                     @Override
                     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                         Object returnValue = method.invoke(target, args);
                         return returnValue;
                     }
            });
    }
}
</code></pre>
<p>测试类</p>
<pre><code class="language-Java">public class Test {
   public static void mian(String[] args){
       //目标对象
       ITeacherDao target = new TeacherDao();
       
       //代理对象的生成，从这里我们就可以发现与静态代理不同的地方
       ITeacherDao proxy = （ITeacherDao）ProxyFactory.newInstance(target);
       
       proxy.check();//调用了学委的check，实际上是分发给InvocationHandler接口的invoke方法执行
       //想要对目标对象的方法实现增强与控制，我们就可以在invoke方法中实现
       //这样目标对象（接口）所有的接口都被统一管理在invoke方法中
  }
}
</code></pre>
<p>现在我们来看看Retrofit是如何完成动态代理的</p>
<p>同时我们将进入解析创建网络请求 的部分</p>
<h3 id="创建网络请求-解析">创建网络请求 解析</h3>
<pre><code class="language-Java">Call&lt;AlbumBean&gt; call = mApiService.getSongs(song.getName(), 1);
</code></pre>
<p>我们已经知道<code>mApiService</code>是代理对象。</p>
<p>使用<code>getSongs</code>方法会分发给<code>InvocationHandler</code>调用<code>invoke</code>，随后返回一个结果<code>loadServiceMethod(method).invoke(args)</code>，我们先看看<code>loadServiceMethod(method)</code>，再判断它会返回什么。</p>
<pre><code class="language-Java">public &lt;T&gt; T create(final Class&lt;T&gt; service) {
    
  validateServiceInterface(service);
  //验证我们定义的service是一个接口，且不是泛型接口，并且会判断是否进行方法的提前验证
  
  return (T)
      //看到这里应该很眼熟了，动态代理
      Proxy.newProxyInstance(
          service.getClassLoader(),
          new Class&lt;?&gt;[] {service},//直接声明需要实现service接口
          new InvocationHandler() {
            private final Platform platform = Platform.get();
            
            @Override
            public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args)
                throws Throwable {
              //因为有代理类的生成，默认继承 Object 类
              //所以如果是 Object.class，默认调用它的方法
              //安全性保护
              if (method.getDeclaringClass() == Object.class) {
                return method.invoke(this, args);
              }
              //判断参数，三目运算
              //安全性保护
              args = args != null ? args : emptyArgs;
              
              //判断如果是默认方法，就执行 platform 的默认方法，否则执行loadServiceMethod方法的invoke方法
              return platform.isDefaultMethod(method)
                  ? platform.invokeDefaultMethod(method, service, proxy, args)
                  : loadServiceMethod(method).invoke(args);
                  //很明显，最需要关注的就是loadServiceMethod(method).invoke(args);
            }
          });
}
</code></pre>
<p>来到<code>loadServiceMethod方法</code>，我们可以看见<em><strong>返回的对象是由</strong></em>***<code>ServiceMethod.parseAnnotations（）</code>***<em><strong>方法创建</strong></em>的，那么我们再深入一下</p>
<pre><code class="language-Java">private final Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;();

ServiceMethod&lt;?&gt; loadServiceMethod(Method method) {
  //从 ConcurrentHashMap 中取一个 ServiceMethod 如果存在直接返回，即单例模式
  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);
  if (result != null) return result;
  
  //锁
  synchronized (serviceMethodCache) {
    //通过 ServiceMethod.parseAnnotations(this, method);方法创建一个 ServiceMethod 对象
    result = serviceMethodCache.get(method);
    if (result == null) {
      //我们又一次见到了注释（Annotation）
      //ServiceMethod.parseAnnotations（）方法创建了一个对象
      result = ServiceMethod.parseAnnotations(this, method);
      
      //以method为键
      //用 Map 把创建的 ServiceMethod 对象缓存起来，因为我们的请求方法可能会调用多次，缓存提升性能。
      //这就是我们在之前见到的在Retrofit类内的变量
      serviceMethodCache.put(method, result);
    }
  }
  return result;
}
</code></pre>
<p>我们看看我们的老熟人——注释（Annotation）, 在<code>ServiceMethod类</code>的中出现了它的身影，</p>
<pre><code class="language-Java">static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) {
  //通过 RequestFactory 解析注解，然后返回 RequestFactory 对象
  RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);
  ...
  //把 RequestFactory 对象传给 HttpServiceMethod，
  //同时也返回一个HttpServiceMethod.parseAnnotations()创建的对象
  return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);
}
</code></pre>
<p>我们先看看<code>RequestFactory.</code><em><code>parseAnnotations（...）</code>**里</em>发生了什么</p>
<pre><code class="language-Java">//RequestFactory.java
final class RequestFactory {
  static RequestFactory parseAnnotations(Retrofit retrofit, Method method) {
    //看build方法
    return new Builder(retrofit, method).build();
  }
  
  //build方法
  RequestFactory build() {
    //遍历 API 接口上定义的方法注解，然后处理注解
    for (Annotation annotation : methodAnnotations) {
      parseMethodAnnotation(annotation);
      //在Retrofit中就是处理GET、POST等注释
    }

   ....

    return new RequestFactory(this);
  }
}
</code></pre>
<p>其实 RequestFactory 这个类还有 <code>parseParameter</code> 和 <code>parseParameterAnnotation</code>这个就是解析<em><strong>方法参数上 的注解</strong></em>，限于篇幅就选择略过。</p>
<p>这也就是你编写的注释最终变成请求的重要一环，<code>RequestFactory.parseAnnotations</code>，会解析方法上的注解，来存到 RequestFactory 的内部。我们也可以通过RequestFactory的名字，明白它的作用。</p>
<p>现在我们再返回去研究<code>HttpServiceMethod.parseAnnotations()</code>这个方法，直到明白<code>result</code>到底是什么对象，即<code>loadServiceMethod方法</code>返回了什么对象。</p>
<pre><code class="language-Java">static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(
    Retrofit retrofit, Method method, RequestFactory requestFactory) {
     
    ......
    // 得到接口方法的返回值信息
    adapterType = method.getGenericReturnType();
    ......
    
    // 得到数据适配器
    // 从callAdapterFactories列表里找到一个适合处理这个method的CallAdapter
    CallAdapter&lt;ResponseT, ReturnT&gt; 
        callAdapter = createCallAdapter(retrofit, method, adapterType, annotations);
    ......
    // 得到数据解析器
    // 负责把服务器返回的数据（一般由 ResponseBody 封装）转化为 T 类型的对象；
    // 从converterFactories列表里找到一个适合处理这个method的对象
    Converter&lt;ResponseBody, ResponseT&gt; 
        responseConverter = createResponseConverter(retrofit, method, responseType);

     okhttp3.Call.Factory callFactory = retrofit.callFactory;
     
     //以上得到的适配器、解析器
     
     //不是 Kotlin 的挂起函数
     if (!isKotlinSuspendFunction) {
     //把requestFactory传给CallAdapted，同时把给callFactory、callAdapter、responseConverte传给子类
     //如果不是 Kotlin 的挂起函数，返回是的 CallAdapted 对象
         return new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);
     } 
     
  ....
}
    //现在我们再来看看CallAdapted
    //CallAdapted 是 HttpServiceMethod 的内部类，也是 HttpServiceMethod 的子类
    CallAdapted(
        RequestFactory requestFactory,
        okhttp3.Call.Factory callFactory,
        Converter&lt;ResponseBody, ResponseT&gt; responseConverter,
        CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter) {
        //这里把 requestFactory 传给 super 父类的构造参数里了,也就是 HttpServiceMethod
        super(requestFactory, callFactory, responseConverter);
        this.callAdapter = callAdapter;
    }
    
    //HttpServiceMethod类是ServiceMethod 的子类
    //也就是说CallAdapted 也是ServiceMethod 的子类
    HttpServiceMethod(
        RequestFactory requestFactory,
        okhttp3.Call.Factory callFactory,
        Converter&lt;ResponseBody, ResponseT&gt; responseConverter) {
        // HttpServiceMethod 的 requestFactory 成员变量保存这个 RequestFactory 对象
        this.requestFactory = requestFactory;
        this.callFactory = callFactory;
        this.responseConverter = responseConverter;
}
</code></pre>
<p>到这里，我们总算清楚了，返回是的 CallAdapted 对象，注意CallAdapted 也是ServiceMethod 的子类。</p>
<p>但是别忘了，在<code>loadServiceMethod(method)</code>后面还接着调用了<code>invoke(args)</code>，也就是说调用了**<code>ServiceMethod 的 invoke 方法</code><strong><strong>，但是</strong></strong><code>ServiceMethod的invoke 方法</code><strong><strong>是一个抽象方法，具体的实现是</strong> **<code>HttpServiceMethod类</code></strong>**。**</p>
<p>我们再看看<code>HttpServiceMethod类的invoke方法</code></p>
<pre><code class="language-Java">//ReturnT也是泛型，只不过把名字改得可读性强一些。
@Override
final @Nullable ReturnT invoke(Object[] args) {
  //创建了一个Call对象，是 OkHttpCall，在这里我们还可以看见requestFactory的出现
  //此后call将进入无限传递
  Call&lt;ResponseT&gt; call = new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);
  //在不使用 Kotlin 协程的情况下
  //其实调用的是子类 CallAdapted 的 adapt，最终会传递给CallAdapter使用
  return adapt(call, args);
}

//因为会调用  HttpServiceMethod 的 invoke 方法
//会把这个 RequestFactory 对象会继续传递给 OkHttpCall 类中
//所以我们往OkHttpCall的代码看看
//注意换类了
//OkHttpCall.java
OkHttpCall(
    RequestFactory requestFactory,
    Object[] args,
    okhttp3.Call.Factory callFactory,
    Converter&lt;ResponseBody, T&gt; responseConverter) {
      //给 OkHttpCall 的requestFactory成员变量赋值
      this.requestFactory = requestFactory;
      this.args = args;
      this.callFactory = callFactory;
      this.responseConverter = responseConverter;
}
</code></pre>
<p><code>HttpServiceMethod的invoke方法</code>中，把前面解析接口方法获得的所有参数，组合成一个<code>Http请求</code>。然后把执行流程转交给<code>adapt方法</code>，这里传入的<code>call是OkHttpCall类型</code>。在<code>HttpServiceMethod</code>的子类<code>CallAdapted</code>中，执行又交给了请求适配器（CallAdapter）。</p>
<pre><code class="language-Java">static final class CallAdapted&lt;ResponseT, ReturnT&gt; extends HttpServiceMethod&lt;ResponseT, ReturnT&gt; {
  private final CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter;

  CallAdapted(
      RequestFactory requestFactory,
      okhttp3.Call.Factory callFactory,
      Converter&lt;ResponseBody, ResponseT&gt; responseConverter,
      CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter) {
    //传给父类requestFactory, callFactory, responseConverter
    super(requestFactory, callFactory, responseConverter);
    //callAdapter来自于父类
    this.callAdapter = callAdapter;
  }

  @Override
  protected ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args) {
  
    return callAdapter.adapt(call);
    
    //call是OkHttpCall类型
    //在没有设置CallAdapter的情况下，选用的是DefaultCallAdapterFactory生产CallAdapter
  }
}

final class DefaultCallAdapterFactory extends Factory {

    @Nullable
    public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
        ...
            return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() {
                public Type responseType() {
                    return responseType;
                }

                public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) {
                    return (Call)(executor == null ? call : new DefaultCallAdapterFactory.ExecutorCallbackCall(executor, call));
                    //在这里我们可以看见ExecutorCalbackCall的创建返回
                    //这里传的call，就是上面我们反复提及的OkHttpCall类型的call
                }
            };
    }
</code></pre>
<p>至此，<code>loadServiceMethod(...).invoke(...)</code>方法的执行流程就结束了，最终返回的就是一个<code>OkHttpCall</code>对象（Android 平台返回的是<code>ExecutorCalbackCall</code>，它是<code>OKHttpCall</code>实例的装饰器，扩展了<code>OKHttpCall</code>异步请求回调处理逻辑），同时准备好了数据适配器、以及数据解析器。</p>
<h3 id="执行网络请求-解析">执行网络请求 解析</h3>
<pre><code class="language-Java">call.enqueue(new Callback&lt;AlbumBean&gt;() {
            @Override
            public void onResponse(Call&lt;AlbumBean&gt; call, Response&lt;AlbumBean&gt; response) {
                // 对返回的数据使用之前设置的数据转换器（Converter）解析返回的数据，
                // 最终得到一个Response&lt;T&gt;对象
                ...
            }
 
            @Override
            public void onFailure(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t) {
                ...
            }
        });
</code></pre>
<p>由上面的解析得知，返回的<code>call</code>实际上是一个<code>ExecutorCalbackCall</code>对象，但是在它的<code>enqueue</code>方法中实际上，执行的是<code>OkHttpCall.enqueue</code>方法。</p>
<p>我们直接去<code>OkHttpCall</code>类中观察。</p>
<pre><code class="language-Java">//OkHttpCall.java
@Override
public void enqueue(final Callback&lt;T&gt; callback) {
  Objects.requireNonNull(callback, &quot;callback == null&quot;);

  //声明一个 okhttp3.Call 对象，用来进行网络请求
  okhttp3.Call call;
  Throwable failure;

  synchronized (this) {
    if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);
    executed = true;

    call = rawCall;
    failure = creationFailure;
    if (call == null &amp;&amp; failure == null) {
      try {
        //给 okhttp3.Call 对象进行赋值
        //等一下我们再详细解析
        call = rawCall = createRawCall();
      } catch (Throwable t) {
        throwIfFatal(t);
        failure = creationFailure = t;
      }
    }
  }

  if (failure != null) {
    callback.onFailure(this, failure);
    return;
  }

  if (canceled) {
    call.cancel();
  }

  //调用 okhttp3.Call 的 enqueue 方法，进行真正的网络请求
  call.enqueue(
      new okhttp3.Callback() {
        @Override
        public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {
          Response&lt;T&gt; response;
          try {
            //解析响应
            //响应转换器在这里起的作用，对接口的返回结果进行了转换。
            response = parseResponse(rawResponse);
          } catch (Throwable e) {
            throwIfFatal(e);
            callFailure(e);
            return;
          }

          try {
            //成功的回调
            callback.onResponse(OkHttpCall.this, response);
          } catch (Throwable t) {
            throwIfFatal(t);
            t.printStackTrace(); 
          }
        }

        @Override
        public void onFailure(okhttp3.Call call, IOException e) {
          callFailure(e);
        }

        private void callFailure(Throwable e) {
          try {
            //失败的回调
            callback.onFailure(OkHttpCall.this, e);
          } catch (Throwable t) {
            throwIfFatal(t);
            t.printStackTrace();
          }
        }
      });
}
</code></pre>
<p>我们再来看看，okhttp3.Call 对象到底是怎么创建的，看向 <code>call = rawCall = createRawCall()</code>这一行</p>
<pre><code class="language-Java">//注意以下都是在OkHtttpCall类中
private final okhttp3.Call.Factory callFactory;

private okhttp3.Call createRawCall() throws IOException {
  //出现了callFactory，同时也出现了我们眼熟的requestFactory
  // 我们在之前就发现了callFactory是由构造方法中赋值的
  // 即callFactory 的值是从 Retrofit 这个对象拿到的
  // requestFactory.create(args)方法会返回一个 Request 的对象
  // 此时的RequestFactory的各个成员变量在解析注解那一步都赋值了
  // 最终 requestFactory 的值用来构造 okhttp3.Request 的对象
  okhttp3.Call call = callFactory.newCall(requestFactory.create(args));
  if (call == null) {
    throw new NullPointerException(&quot;Call.Factory returned null.&quot;);
  }
  return call;
}
</code></pre>
<p>我们往Retrofit类回看，发现，原来 <code>callFactory </code>实际是一个<code>OkHttpClient</code>对象，也就是 OkHttpClient 创建了一个 Call 对象。是不是很眼熟？上周的OkHttp中也差不多是这一套。</p>
<pre><code class="language-Java">//Retrofit.java
public static final class Builder {
    public Retrofit build() {
      okhttp3.Call.Factory callFactory = this.callFactory;
      if (callFactory == null) {
        callFactory = new OkHttpClient();
      }

}
</code></pre>
<p>现在我们来看看是如何解析响应的</p>
<pre><code class="language-Java">private final Converter&lt;ResponseBody, T&gt; responseConverter;

Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException {
    ResponseBody rawBody = rawResponse.body();

    ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody);
    
    //这里的responseConverter，实际上，
    //是由HttpServiceMethod里的createResponseConverter得到
    T body = responseConverter.convert(catchingBody);//通过 responseConverte 调用convert方法，完成对响应的解析
    
    return Response.success(body, rawResponse);

  }
</code></pre>
<p>到这里，对<code>Retrofit</code>的大体实现，以及一些细末枝节，已经完成了解析。文章中可能出现一些错误，由可能请尽情指正批评。当然还有很多具体细节没有研究，比如，Retrofit和<code>RxJava</code>、<code>Kotiln</code>的配合实现的原理，由于时间原因就不进行详细介绍。但是阅读完本文后，相信能更好地阅读其他作者的关于对Retrofit原理解析的文章。</p>
<h3 id="总结">总结</h3>
<p><code>Retrofit</code>一共使用了六种<em>设计模式</em>，分别为：</p>
<ul>
<li><code>建造者模式</code>：<code>Retrofit</code>、<code>Request</code>等复杂对象的创建。</li>
<li><code>外观模式</code>：<code>Retrofit</code>类提供了整个系统的入口</li>
<li><code>代理模式</code>：<code>service</code>接口代理类的创建</li>
<li><code>工厂模式</code> ：<code>xxxFactory</code></li>
<li><code>策略模式</code>： 到底选择哪种<code>Converter</code>，<code>CallAdapter</code></li>
<li><code>适配器模式</code> ：<code>adapt方法</code>将<code>OkHttpCall</code> 和 <code>MainThreadExecutor</code>两个实例对象适配为<code>ExecutorCallbackCall</code>，使得在执行过程中就具备了切换到UI线程的功能。</li>
</ul>
<p>以上这些设计模式，使Retrofit完成了高度解耦，并且具有一定的拓展性。</p>
<p>在未来，自己架构或者开发开源库时，使用上述设计模式，我相信一定能写优雅高效的代码。</p>
<p>通过对源码解析，我们对Retrofit的理解会更加深入，这样以后完成对Retrofit的魔改，或者对Retrofit的封装会更加完善。</p>
<h3 id="补充">补充：</h3>
<p>鉴于网上对设计模式的介绍，有些良莠不齐，部分介绍过于繁琐，所以补充一下，一些设计模式在Retrofit哪里有使用。</p>
<h4 id="策略模式">策略模式</h4>
<p>模式定义：</p>
<p>即将<em><strong>不同算法</strong></em>封装到<em><strong>具有共同接口的独立的类</strong></em>中，<em><strong>从而使得它们可以相互替换</strong></em>。策略模式使得算法可以在不影响到客户端的情况下发生变化。</p>
<p>完成一项任务，往往可以有多种不同的方式，<em><strong>每一种方式称为一个策略</strong></em>，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。</p>
<blockquote>
<p>使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。</p>
</blockquote>
<p>策略模式包含以下3个角色：</p>
<ul>
<li><code>Context（环境类）</code>：负责使用算法策略，其中维持了一个抽象策略类的引用实例。</li>
<li><code>Strategy（抽象策略类）</code>：所有策略类的父类，为所支持的策略算法声明了抽象方法。=&gt; 既可以是抽象类也可以是接口。</li>
<li><code>ConcreteStrategy（具体策略类）</code>：实现了在抽象策略类中声明的方法。</li>
</ul>
<p>举个栗子，<code>Context（环境类）</code>是<code>Retrofit</code>类，维持了对<code>CallAdapter&lt;R, T&gt;</code>的引用</p>
<pre><code class="language-Java">//接口定义，作为Strategy（抽象策略类）
public interface CallAdapter&lt;R, T&gt; {
    Type responseType();
    T adapt(Call&lt;R&gt; call);
}
//rxjava的适配器 ConcreteStrategy（具体策略类）
final class RxJavaCallAdapter&lt;R&gt; implements CallAdapter&lt;R, Object&gt; {
      ...
}
//默认的适配器 ConcreteStrategy（具体策略类）
DefaultCallAdapterFactoryCallAdapter&lt;Object, Call&lt;?&gt;&gt;() {
    ...
};
//安卓适配器 ConcreteStrategy（具体策略类）
ExecutorCallAdapterFactoryCallAdapter&lt;Object, Call&lt;?&gt;&gt;() {
    ...
};
</code></pre>
<p>在这里我们需要<em><strong>认识一下工厂模式、策略模式的区别</strong></em></p>
<ul>
<li>工厂模式：强调产生了多个不同的 <code>CallAdapter</code> ，作用在创建对象之前。</li>
<li>策略模式：强调的是这些多个不同的 <code>CallAdapter</code> 的接口方法的具体实现，作用在创建对象之后。</li>
</ul>
<blockquote>
<p>这就好比一个对汽车不甚了解的人去买车，他在那一比划，说要什么什么样的，销售部门根据他的这个“比划”来形成一份订单，这就是工厂模式下的工作方式。</p>
<p>而策略模式下那个顾客就是个行家，他自己给出了订单的详细信息，销售部门只是转了一下手就交给生产部门去做了。这也就是说，策略模式必须要求客户明白有哪些具体策略，这意味着必须对客户暴露所有的策略类。</p>
</blockquote>
<h4 id="适配器模式">适配器模式</h4>
<p>将一个类的接口转化为客户希望的另一个接口。Adapter模式使得原本由于接口不同而不能一起工作的那些类可以在一起工作。</p>
<p>//TODO:看有没有时间再补充😋</p>
<p>建议配合这篇文章观看</p>
<p>https://zhuanlan.zhihu.com/p/549063015</p>
<h2 id="参考文章">参考文章：</h2>
<p>https://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html</p>
<p>https://segmentfault.com/a/1190000011291179</p>
<p>https://juejin.cn/post/6862368973888061453</p>
<p>https://www.runoob.com/w3cnote/java-annotation.html</p>
<p>https://www.jianshu.com/p/be290ccea05a</p>
<p>https://allenwu.itscoder.com/use-of-proxy</p>
<p>https://shusheng007.top/2021/09/08/025/</p>
<p>https://juejin.cn/post/6869584323079569415</p>
<p>https://www.cnblogs.com/younghao/p/6098329.html</p>
<p>https://github.com/stven0king/designmode</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#retrofit%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><strong>Retrofit的简单介绍</strong></a></li>
<li><a href="#retrofit%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><strong>Retrofit的简单使用</strong></a>
<ul>
<li><a href="#tips"><strong>Tips：</strong></a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96retrofit%E6%89%93%E9%80%A0%E5%8F%91%E5%B0%84%E5%99%A8"><strong>初始化Retrofit（打造发射器）</strong></a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AEmodel"><strong>创建数据Model</strong></a></li>
<li><a href="#%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%E5%AF%B9%E5%8F%91%E5%B0%84%E7%9B%AE%E6%A0%87%E7%9A%84%E7%A1%AE%E5%AE%9A"><strong>定义接口（对发射目标的确定）</strong></a></li>
<li><a href="#%E9%80%9A%E8%BF%87retrofit%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%AF%B9%E8%B1%A1"><strong>通过Retrofit实例创建接口服务对象</strong></a></li>
<li><a href="#%E5%88%9B%E5%BB%BA-%E6%89%A7%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82">创建、执行网络请求</a></li>
</ul>
</li>
<li><a href="#retrofit%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><strong>Retrofit的结合使用</strong></a></li>
<li><a href="#retrofit%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><strong>Retrofit的源码解析</strong></a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BAretrofit%E5%AE%9E%E4%BE%8B-%E8%A7%A3%E6%9E%90"><strong>创建Retrofit实例</strong> 解析</a>
<ul>
<li><a href="#retrofit%E7%B1%BB">Retrofit类</a></li>
<li><a href="#retrofitbuilder%E7%B1%BB">Retrofit.Builder类</a></li>
</ul>
</li>
<li><a href="#%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3-%E8%A7%A3%E6%9E%90"><strong>定义接口</strong> 解析</a>
<ul>
<li><a href="#%E6%B3%A8%E8%A7%A3">注解</a>
<ul>
<li><a href="#%E5%85%83%E6%B3%A8%E8%A7%A3">元注解</a></li>
<li><a href="#%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3">定义注解</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E6%B3%A8%E8%A7%A3">处理注解</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%B0%8F%E6%80%BB%E7%BB%93">小总结</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%AF%B9%E8%B1%A1-%E8%A7%A3%E6%9E%90"><strong>创建接口服务对象 解析</strong></a><br>
*
<ul>
<li><a href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86">静态代理</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">动态代理</a></li>
</ul>
</li>
<li><a href="#%E5%88%9B%E5%BB%BA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%A7%A3%E6%9E%90">创建网络请求 解析</a></li>
<li><a href="#%E6%89%A7%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E8%A7%A3%E6%9E%90">执行网络请求 解析</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
<li><a href="#%E8%A1%A5%E5%85%85">补充：</a>
<ul>
<li><a href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F">策略模式</a></li>
<li><a href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">适配器模式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">参考文章：</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://kanyewestforreal.github.io/post/remoteview-with-bitmap-anr/">
              <h3 class="post-title">
                关于RemoteView多次设置图片导致其消失的情况
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  This blog is just for me to record the questions, which in my developing.
  <a class="rss" href="https://kanyewestforreal.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
